package grade;

import static model.AbstractLexer.Tokens.*;
import static org.junit.Assert.assertEquals;

import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;

import model.AbstractLexer.Tokens;

// Do not modify.
@RunWith(Parameterized.class)
public class LexerTests {
	@Parameters(name="{index}: {0}")
	public static java.util.Collection<Object[]> data() {
		return java.util.Arrays.asList(new Object[][] {
			{ "test 1?", tokens(BEGIN_TEST, TRUE_LITERAL, END_TEST) },
			{ "test 0?" , tokens(BEGIN_TEST, FALSE_LITERAL, END_TEST) },
			{ "test 1'?" , tokens(BEGIN_TEST, TRUE_LITERAL, NEGATION, END_TEST) },
			{ "test 0'?" , tokens(BEGIN_TEST, FALSE_LITERAL, NEGATION, END_TEST) },

			{ "test 1 -> 1?" , tokens(BEGIN_TEST, TRUE_LITERAL, IMPLICATION, TRUE_LITERAL, END_TEST) },
			{ "test 1 -> 0?" , tokens(BEGIN_TEST, TRUE_LITERAL, IMPLICATION, FALSE_LITERAL, END_TEST) },
			{ "test 0 -> 1?" , tokens(BEGIN_TEST, FALSE_LITERAL, IMPLICATION, TRUE_LITERAL, END_TEST) },
			{ "test 0 -> 0?" , tokens(BEGIN_TEST, FALSE_LITERAL, IMPLICATION, FALSE_LITERAL, END_TEST) },

			{ "test 1 <-> 1?" , tokens(BEGIN_TEST, TRUE_LITERAL, EQUIVALENCE, TRUE_LITERAL, END_TEST) },
			{ "test 1 <-> 0?" , tokens(BEGIN_TEST, TRUE_LITERAL, EQUIVALENCE, FALSE_LITERAL, END_TEST) },
			{ "test 0 <-> 1?" , tokens(BEGIN_TEST, FALSE_LITERAL, EQUIVALENCE, TRUE_LITERAL, END_TEST) },
			{ "test 0 <-> 0?" , tokens(BEGIN_TEST, FALSE_LITERAL, EQUIVALENCE, FALSE_LITERAL, END_TEST) },

			{ "bool P = 1, bool Q = 1, test P ^ Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, test P ^ Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, test P ^ Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, test P ^ Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, END_TEST) },

			{ "bool P = 1, bool Q = 1, bool R = 1, test P ^ Q ^ R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 1, bool R = 0, test P ^ Q ^ R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, bool R = 1, test P ^ Q ^ R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, bool R = 0, test P ^ Q ^ R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, bool R = 1, test P ^ Q ^ R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, bool R = 0, test P ^ Q ^ R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, bool R = 1, test P ^ Q ^ R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, bool R = 0, test P ^ Q ^ R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, END_TEST) },

			{ "bool P = 1, bool Q = 1, test P v Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, test P v Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, test P v Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, test P v Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, END_TEST) },

			{ "bool P = 1, bool Q = 1, bool R = 1, test P v Q v R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 1, bool R = 0, test P v Q v R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, bool R = 1, test P v Q v R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, bool R = 0, test P v Q v R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, bool R = 1, test P v Q v R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, bool R = 0, test P v Q v R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, bool R = 1, test P v Q v R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, bool R = 0, test P v Q v R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, END_TEST) },

			{ "bool P = 1, bool Q = 1, test P -> Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, test P -> Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, test P -> Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, test P -> Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, END_TEST) },

			{ "bool P = 1, bool Q = 1, bool R = 1, test P -> Q -> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 1, bool R = 0, test P -> Q -> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, bool R = 1, test P -> Q -> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, bool R = 0, test P -> Q -> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, bool R = 1, test P -> Q -> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, bool R = 0, test P -> Q -> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, bool R = 1, test P -> Q -> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, bool R = 0, test P -> Q -> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, END_TEST) },

			{ "bool P = 1, bool Q = 1, test P <-> Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, test P <-> Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, test P <-> Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, test P <-> Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, END_TEST) },

			{ "bool P = 1, bool Q = 1, bool R = 1, test P <-> Q <-> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 1, bool R = 0, test P <-> Q <-> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, bool R = 1, test P <-> Q <-> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, bool R = 0, test P <-> Q <-> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, bool R = 1, test P <-> Q <-> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, bool R = 0, test P <-> Q <-> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, bool R = 1, test P <-> Q <-> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, bool R = 0, test P <-> Q <-> R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, END_TEST) },

			{ "bool P = 1, test P?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, test P?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, test P'?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, NEGATION, END_TEST) },
			{ "bool P = 0, test (P')'?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, NEGATION, CLOSE_PAREN, NEGATION, END_TEST) },
			{ "bool P = 1, test (P)?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, CLOSE_PAREN, END_TEST) },
			{ "bool P = 0, test ((P))?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, OPEN_PAREN, VARIABLE_NAME, CLOSE_PAREN, CLOSE_PAREN, END_TEST) },

			{ "bool P = 1, bool Q = 1, test (P ^ Q)' <-> (P' v Q')?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, CLOSE_PAREN, NEGATION, EQUIVALENCE, OPEN_PAREN, VARIABLE_NAME, NEGATION, DISJUNCTION, VARIABLE_NAME, NEGATION, CLOSE_PAREN, END_TEST) },
			{ "bool P = 1, bool Q = 0, test (P ^ Q)' <-> (P' v Q')?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, CLOSE_PAREN, NEGATION, EQUIVALENCE, OPEN_PAREN, VARIABLE_NAME, NEGATION, DISJUNCTION, VARIABLE_NAME, NEGATION, CLOSE_PAREN, END_TEST) },
			{ "bool P = 0, bool Q = 1, test (P ^ Q)' <-> (P' v Q')?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, CLOSE_PAREN, NEGATION, EQUIVALENCE, OPEN_PAREN, VARIABLE_NAME, NEGATION, DISJUNCTION, VARIABLE_NAME, NEGATION, CLOSE_PAREN, END_TEST) },
			{ "bool P = 0, bool Q = 0, test (P ^ Q)' <-> (P' v Q')?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, CONJUNCTION, VARIABLE_NAME, CLOSE_PAREN, NEGATION, EQUIVALENCE, OPEN_PAREN, VARIABLE_NAME, NEGATION, DISJUNCTION, VARIABLE_NAME, NEGATION, CLOSE_PAREN, END_TEST) },

			{ "bool P = 1, bool Q = 1, test (P v Q)' <-> (P' ^ Q')?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, CLOSE_PAREN, NEGATION, EQUIVALENCE, OPEN_PAREN, VARIABLE_NAME, NEGATION, CONJUNCTION, VARIABLE_NAME, NEGATION, CLOSE_PAREN, END_TEST) },
			{ "bool P = 1, bool Q = 0, test (P v Q)' <-> (P' ^ Q')?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, CLOSE_PAREN, NEGATION, EQUIVALENCE, OPEN_PAREN, VARIABLE_NAME, NEGATION, CONJUNCTION, VARIABLE_NAME, NEGATION, CLOSE_PAREN, END_TEST) },
			{ "bool P = 0, bool Q = 1, test (P v Q)' <-> (P' ^ Q')?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, CLOSE_PAREN, NEGATION, EQUIVALENCE, OPEN_PAREN, VARIABLE_NAME, NEGATION, CONJUNCTION, VARIABLE_NAME, NEGATION, CLOSE_PAREN, END_TEST) },
			{ "bool P = 0, bool Q = 0, test (P v Q)' <-> (P' ^ Q')?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, DISJUNCTION, VARIABLE_NAME, CLOSE_PAREN, NEGATION, EQUIVALENCE, OPEN_PAREN, VARIABLE_NAME, NEGATION, CONJUNCTION, VARIABLE_NAME, NEGATION, CLOSE_PAREN, END_TEST) },

			{ "bool P = 1, bool Q = 1, test (P -> Q) <-> (P' v Q)?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, CLOSE_PAREN, EQUIVALENCE, OPEN_PAREN, VARIABLE_NAME, NEGATION, DISJUNCTION, VARIABLE_NAME, CLOSE_PAREN, END_TEST) },
			{ "bool P = 1, bool Q = 0, test (P -> Q) <-> (P' v Q)?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, CLOSE_PAREN, EQUIVALENCE, OPEN_PAREN, VARIABLE_NAME, NEGATION, DISJUNCTION, VARIABLE_NAME, CLOSE_PAREN, END_TEST) },
			{ "bool P = 0, bool Q = 1, test (P -> Q) <-> (P' v Q)?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, CLOSE_PAREN, EQUIVALENCE, OPEN_PAREN, VARIABLE_NAME, NEGATION, DISJUNCTION, VARIABLE_NAME, CLOSE_PAREN, END_TEST) },
			{ "bool P = 0, bool Q = 0, test (P -> Q) <-> (P' v Q)?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, OPEN_PAREN, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, CLOSE_PAREN, EQUIVALENCE, OPEN_PAREN, VARIABLE_NAME, NEGATION, DISJUNCTION, VARIABLE_NAME, CLOSE_PAREN, END_TEST) },

			{ "bool P = 1, bool Q = 1, test P -> Q <-> P' v Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, NEGATION, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, test P -> Q <-> P' v Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, NEGATION, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, test P -> Q <-> P' v Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, NEGATION, DISJUNCTION, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, test P -> Q <-> P' v Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, NEGATION, DISJUNCTION, VARIABLE_NAME, END_TEST) },

			{ "bool P = 1, bool Q = 1, test P -> Q <-> Q' -> P'?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, NEGATION, IMPLICATION, VARIABLE_NAME, NEGATION, END_TEST) },
			{ "bool P = 1, bool Q = 0, test P -> Q <-> Q' -> P'?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, NEGATION, IMPLICATION, VARIABLE_NAME, NEGATION, END_TEST) },
			{ "bool P = 0, bool Q = 1, test P -> Q <-> Q' -> P'?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, NEGATION, IMPLICATION, VARIABLE_NAME, NEGATION, END_TEST) },
			{ "bool P = 0, bool Q = 0, test P -> Q <-> Q' -> P'?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, IMPLICATION, VARIABLE_NAME, EQUIVALENCE, VARIABLE_NAME, NEGATION, IMPLICATION, VARIABLE_NAME, NEGATION, END_TEST) },

			{ "Bool P = 1, Bool Q = P, Test Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, VARIABLE_NAME, END_BOOL, BEGIN_TEST, VARIABLE_NAME, END_TEST) },
			{ "BOOL P = 0, BOOL Q = P, TEST Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, VARIABLE_NAME, END_BOOL, BEGIN_TEST, VARIABLE_NAME, END_TEST) },
			{ "BoOl P = 1, bOoL Q = P', TeSt Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, VARIABLE_NAME, NEGATION, END_BOOL, BEGIN_TEST, VARIABLE_NAME, END_TEST) },
			{ "boOL P = 0, BOol Q = P', tEsT Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, VARIABLE_NAME, NEGATION, END_BOOL, BEGIN_TEST, VARIABLE_NAME, END_TEST) },

			{ "bool P = 1, bool Q = 1, bool R = P' ^ Q', test R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, VARIABLE_NAME, NEGATION, CONJUNCTION, VARIABLE_NAME, NEGATION, END_BOOL, BEGIN_TEST, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, bool Q = 0, bool R = P' ^ Q', test R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, VARIABLE_NAME, NEGATION, CONJUNCTION, VARIABLE_NAME, NEGATION, END_BOOL, BEGIN_TEST, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 1, bool R = P' ^ Q', test R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, VARIABLE_NAME, NEGATION, CONJUNCTION, VARIABLE_NAME, NEGATION, END_BOOL, BEGIN_TEST, VARIABLE_NAME, END_TEST) },
			{ "bool P = 0, bool Q = 0, bool R = P' ^ Q', test R?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, FALSE_LITERAL, END_BOOL, BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, VARIABLE_NAME, NEGATION, CONJUNCTION, VARIABLE_NAME, NEGATION, END_BOOL, BEGIN_TEST, VARIABLE_NAME, END_TEST) },

			{ "test P?" , tokens(BEGIN_TEST, VARIABLE_NAME, END_TEST) },
			{ "bool P = 1, test Q?" , tokens(BEGIN_BOOL, VARIABLE_NAME, ASSIGNMENT, TRUE_LITERAL, END_BOOL, BEGIN_TEST, VARIABLE_NAME, END_TEST) },
			{ "bool ->->P? Q" , tokens(BEGIN_BOOL, IMPLICATION, IMPLICATION, VARIABLE_NAME, END_TEST, VARIABLE_NAME) },
			{ "^vTEST bool ' P )" , tokens(CONJUNCTION, DISJUNCTION, BEGIN_TEST, BEGIN_BOOL, NEGATION, VARIABLE_NAME, CLOSE_PAREN) },
		});
	}

	public static Tokens[] tokens(Tokens... tokens) {
		return tokens;
	}

	@Parameter(value=0)
	public String sentence;

	@Parameter(value=1)
	public Tokens[] tokens;

	private static model.AbstractLexer LEXER;

	@BeforeClass
	public static void setup() {
		LEXER = new unit.Lexer();
	}

	@Test
	public void testSentenceLexemes() {
		LEXER.initialize(sentence.toCharArray());

		for (int i = 0; i < tokens.length; i++) {
			LEXER.lex();

			assertEquals(
				"Token " + (i+1) + " of " + tokens.length + " mismatched,",
				tokens[i],
				LEXER.TOKEN
			);
		}
	}
}
